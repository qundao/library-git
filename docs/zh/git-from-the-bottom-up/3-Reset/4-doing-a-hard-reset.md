# 执行硬重置

硬重置（`--hard` 选项）具有非常危险的潜力，因为它能够同时执行两种不同的操作：首先，如果你对当前的 HEAD 执行硬重置，它将擦除工作树中的所有更改，以使你当前的文件与 HEAD 的内容相匹配。

还有另一条命令 `checkout`，如果索引为空，它的操作方式与 `reset --hard` 相同。否则，它会强制你的工作树与索引匹配。

现在，如果你对较早的提交执行硬重置，这与首先执行软重置，然后使用 `reset --hard` 重置你的工作树是相同的。因此，以下命令是等效的：

```bash
$ git reset --hard HEAD~3  # 回到过去，丢弃更改
$ git reset --soft HEAD~3  # 将 HEAD 设置为指向较早的提交
$ git reset --hard  # 擦除工作树中的差异
```

如你所见，执行硬重置可能会非常破坏性。幸运的是，有一种更安全的方法可以实现相同的效果，即使用 Git 存储（查看下一节）：

```bash
$ git stash
$ git checkout -b new-branch HEAD~3   # 回到过去！
```

如果你不确定是否现在就想修改当前分支，此方法有两个明显的优点：

1. 它将你的工作保存在存储中，你随时可以回到其中。请注意，存储不是特定于分支的，因此你可以在一个分支上存储树的状态，并在稍后将差异应用到另一个分支上。
2. 它将你的工作树恢复到过去的状态，但在一个新的分支上，因此如果你决定对过去的状态提交更改，你不会更改原始分支。

如果你对 `new-branch` 进行了更改，然后决定将其变为新的主分支，请运行以下命令：

```bash
$ git branch -D master  # 再见旧主分支（仍在 reflog 中）
$ git branch -m new-branch master  # 新分支现在是我的主分支
```

这个故事的寓意是：尽管你可以使用 `reset --soft` 和 `reset --hard` 在当前分支上进行重大的手术（这也会改变工作树），但你为什么要这样做呢？Git 使得工作分支如此轻松且廉价，几乎总是值得在一个分支上进行破坏性的修改，然后将该分支移动到原始主分支的位置。这几乎具有西斯般的吸引力......

如果你不小心运行 `reset --hard`，不仅丢失了当前的更改，还删除了主分支上的提交，那该怎么办呢？嗯，除非你已经养成了使用存储来拍摄快照的习惯（请参阅下一节），否则你无法恢复丢失的工作树。但是你可以再次使用带有 reflog 的 `reset --hard` 将分支恢复到之前的状态（这也将在下一节中解释）：

```bash
$ git reset --hard HEAD@{1}   # 从更改前的 reflog 恢复
```

为了安全起见，在执行 `reset --hard` 前，请先运行 `stash`。这将在以后节省你很多白发。如果你已经运行了存储，现在可以使用它来恢复你的工作树更改：

```bash
$ git stash  # 因为这总是一件好事
$ git reset --hard HEAD~3  # 回到过去
$ git reset --hard HEAD@{1}  # 哎呀，那是一个错误，撤销它！
$ git stash apply  # 并恢复我的工作树更改
```
