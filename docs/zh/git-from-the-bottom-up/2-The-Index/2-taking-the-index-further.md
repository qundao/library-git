# 将索引进行到底

让我们来看看索引... 通过它，你可以预先为一组更改建立一个补丁，然后逐步将其提交到仓库中。现在，我在哪里听过这个概念呢...

如果你在想“Quilt！”，那么你就完全正确。实际上，索引与 Quilt 几乎没有什么不同，它只是增加了一项限制，即一次只允许构建一个补丁。

但是，如果不是在 `foo.c` 中有两组更改，而是有四组呢？使用普通的 Git，我将不得不逐个拉出每一组，进行提交，然后拉出下一组。使用索引会使这一过程变得更加简单，但是如果我想在提交之前以各种组合进行这些更改的测试怎么办？也就是说，如果我将补丁标记为 A、B、C 和 D，那么在决定是否真正完成任何更改之前，我想测试 A + B、然后是 A + C、然后是 A + D 等等。

Git 本身没有机制允许你在运行时混合和匹配并行的更改集。当然，多个分支可以让你进行并行开发，而索引可以让你将多个更改分成一系列提交，但你不能同时执行两者：在一系列补丁上进行分段，同时选择性地启用和禁用其中一些，以验证补丁在最后提交之前的整体完整性。

要执行这样的操作，你需要一个允许一次性提交多个提交的索引。这正是 Stacked Git 提供的功能。

以下是我使用普通 Git 将两个不同的补丁提交到我的工作树中的方法：

```bash
$ git add -i # 选择第一组更改
$ git commit -m "第一个提交消息"
$ git add -i # 选择第二组更改
$ git commit -m "第二个提交消息"
```

这很好用，但是我不能选择性地禁用第一个提交以单独测试第二个提交。为了做到这一点，我必须执行以下操作：

```bash
$ git log # 找到第一个提交的哈希 ID
$ git checkout -b work <第一个提交的哈希 ID>
$ git cherry-pick <第二个提交的哈希 ID>
<... 运行测试 ...>
$ git checkout master # 返回到主“分支”
$ git branch -D work # 删除我的临时分支
```

肯定有更好的方法！使用 `stg`，我可以将两个补丁都排队，然后以任何顺序重新应用它们，以进行独立或组合测试等。以下是我使用 `stg` 队列相同两个补丁的方式：

```bash
$ stg new patch1
$ git add -i  # 选择第一组更改
$ stg refresh --index
$ stg new patch2
$ git add -i  # 选择第二组更改
$ stg refresh --index
```

现在，如果我想选择性地禁用第一个补丁，以单独测试第二个补丁，那么这将非常简单：

```bash
$ stg applied
patch1
patch2
<... 使用两个补丁进行测试 ...>
$ stg pop patch1
<... 仅使用补丁2进行测试 ...>
$ stg pop patch2
$ stg push patch1
<... 仅使用补丁1进行测试 ...>
$ stg push -a
$ stg commit -a  # 提交所有补丁
```

这绝对比创建临时分支并使用 `cherry-pick` 应用特定提交 ID，然后删除临时分支要容易得多。
