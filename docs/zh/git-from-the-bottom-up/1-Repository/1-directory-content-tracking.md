# 仓库：目录内容追踪

如上所述，Git 的工作原理非常基本：它维护目录内容的快照。许多内部设计都可以根据这个基本任务来理解。

在许多方面，Git 存储库的设计反映了 UNIX 文件系统的结构：一个 **文件系统** 以一个根目录开始，该目录通常由其他目录组成，其中大多数都有叶子节点，或者 **文件**，其中包含数据。关于这些文件内容的元数据同时存储在目录中（名称）和引用这些文件内容的 i 节点中（它们的大小、类型、权限等）。每个 **i 节点** 都有一个唯一的编号，用于标识其相关文件的内容。虽然可能有许多目录条目指向特定的 i 节点（即硬链接），但是 i 节点“拥有”存储在文件系统上的内容。

在内部，Git 具有一个非常相似的结构，尽管存在一两个关键差异。首先，它将文件的内容表示为 **blob**，这些 blob 也是类似目录的叶子节点，称为 **树**。正如 i 节点由系统分配的编号唯一标识一样，blob 的名称是通过计算其大小和内容的 SHA1 散列值得出的。在所有情况下，这只是一个任意的数字，就像 i 节点一样，只是它具有两个额外的属性：首先，它验证了 blob 的内容永远不会更改；其次，相同的内容将始终由相同的 blob 表示，无论它出现在何处：跨提交，跨存储库 —— 甚至跨整个互联网。如果多个树引用相同的 blob，这就像硬链接一样：只要至少有一个链接指向它，blob 就不会从你的存储库中消失。

Git blob 与文件系统的文件之间的区别在于，blob 不存储有关其内容的元数据。所有这些信息都保存在包含该 blob 的树中。一个树可能将这些内容视为 2004 年 8 月创建的名为“foo”的文件，而另一个树可能将相同的内容视为 五年后创建的名为“bar”的文件。在正常的文件系统中，具有相同内容但具有不同元数据的两个文件总是表示为两个独立的文件。为什么会有这种区别？主要是因为文件系统设计用于支持会改变的文件，而 Git 不是。数据在 Git 存储库中是不可变的事实使得所有这些工作都变得不同，因此需要一种不同的设计。事实证明，这种设计允许存储更加紧凑，因为具有相同内容的所有对象都可以共享，无论它们在何处。
