# 提交的美妙之处

一些版本控制系统将“分支”视为神奇的东西，通常将其与“主线”或“主干”区分开来，而其他系统则将这个概念描述得与提交非常不同。但是在 Git 中，分支不是单独的实体：只有 blob、tree 和 commit。由于一个提交可以有一个或多个父提交，而这些提交又可以有父提交，这就使得单个提交能够像分支一样被处理：因为它知道导致它的整个历史。

你可以随时使用 `branch` 命令检查所有顶级引用的提交：

```bash
$ git branch -v
* master 5f1bc85 Initial commit
```

跟我说：分支不过是对提交的命名引用。这样看来，分支和标签是完全相同的，唯一的区别是标签可以有自己的描述，就像它们所引用的提交一样。分支只是名称，而标签是描述性的，“标签”。

但事实是，我们根本不需要使用别名。例如，如果我想的话，我可以仅使用提交的散列 ID 引用存储库中的所有内容。下面是我直接疯狂地将工作树的 HEAD 重置为特定提交的方式：

```bash
$ git reset --hard 5f1bc85
```

`--hard` 选项表示擦除当前工作树中的所有更改，无论它们是否已经被注册为提交或不是（稍后将会对该命令进行更多的介绍）。一个更安全的方式是使用 `checkout`：

```bash
$ git checkout 5f1bc85
```

这里的区别是，工作树中的更改文件会被保留。如果我向 `checkout` 传递 `-f` 选项，在这种情况下它的行为与 `reset --hard` 相同，只是 `checkout` 仅仅会更改工作树，而 `reset --hard` 会将当前分支的 HEAD 更改为引用树的指定版本。

提交为基础的系统的另一个乐趣是，你可以使用单一的词汇重述甚至最复杂的版本控制术语。例如，如果一个提交有多个父提交，则它是一个“合并提交” —— 因为它将多个提交合并为一个。或者，如果一个提交有多个子提交，则它表示一个“分支”的祖先等。但实际上对于 Git 来说，这些东西之间没有任何区别：对于 Git 来说，世界只是提交对象的集合，每个对象都包含一个引用其他树和 blob 的树，后者存储你的数据。比这更复杂的任何东西只是命名的设备。

下面是所有这些组件如何组合在一起的图片：

![提交](../../../images/git-from-the-bottom-up/commits.png)
